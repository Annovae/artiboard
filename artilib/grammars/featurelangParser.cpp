/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : artilib\\grammars\\featurelang.g
 *     -                            On : 2013-09-29 12:51:07
 *     -                for the parser : featurelangParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "featurelangParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   featurelangParserTokenNames[13+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "INTEGER",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'!'",
        (ANTLR_UINT8*) "'&'",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "'@'",
        (ANTLR_UINT8*) "'{'",
        (ANTLR_UINT8*) "'|'",
        (ANTLR_UINT8*) "'}'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "artilib\\grammars\\featurelang.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* featurelangParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new featurelangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
featurelangParser::featurelangParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new featurelangParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
featurelangParser::featurelangParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void featurelangParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( featurelangParserTokenNames );


}

void
featurelangParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
featurelangParser::~featurelangParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return featurelangParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_orExpr_in_formula29_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_orExpr_in_formula29( FOLLOW_orExpr_in_formula29_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_ground_in_term43_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_ground_in_term43( FOLLOW_ground_in_term43_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_10_in_term48_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004500) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_10_in_term48( FOLLOW_10_in_term48_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_orExpr_in_term50_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_orExpr_in_term50( FOLLOW_orExpr_in_term50_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_11_in_term52_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_11_in_term52( FOLLOW_11_in_term52_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_8_in_term57_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004500) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_8_in_term57( FOLLOW_8_in_term57_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_term_in_term59_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_term_in_term59( FOLLOW_term_in_term59_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_andExpr_in_orExpr68_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_andExpr_in_orExpr68( FOLLOW_andExpr_in_orExpr68_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_15_in_orExpr71_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004500) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_15_in_orExpr71( FOLLOW_15_in_orExpr71_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_andExpr_in_orExpr73_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_andExpr_in_orExpr73( FOLLOW_andExpr_in_orExpr73_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_term_in_andExpr84_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_term_in_andExpr84( FOLLOW_term_in_andExpr84_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_9_in_andExpr87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004500) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_9_in_andExpr87( FOLLOW_9_in_andExpr87_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_term_in_andExpr89_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_term_in_andExpr89( FOLLOW_term_in_andExpr89_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_state_set_in_ground103_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_state_set_in_ground103( FOLLOW_state_set_in_ground103_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_13_in_ground105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_13_in_ground105( FOLLOW_13_in_ground105_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_square_set_in_ground107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_square_set_in_ground107( FOLLOW_square_set_in_ground107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_14_in_state_set118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_14_in_state_set118( FOLLOW_14_in_state_set118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_state_set120_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010020) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_ID_in_state_set120( FOLLOW_ID_in_state_set120_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_state_set123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010020) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_ID_in_state_set123( FOLLOW_ID_in_state_set123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_16_in_state_set127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_16_in_state_set127( FOLLOW_16_in_state_set127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_14_in_square_set138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_14_in_square_set138( FOLLOW_14_in_square_set138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_square_in_square_set140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010040) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_square_in_square_set140( FOLLOW_square_in_square_set140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_square_in_square_set143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010040) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_square_in_square_set143( FOLLOW_square_in_square_set143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_16_in_square_set147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_16_in_square_set147( FOLLOW_16_in_square_set147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_INTEGER_in_square159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_INTEGER_in_square159( FOLLOW_INTEGER_in_square159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_12_in_square161_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_12_in_square161( FOLLOW_12_in_square161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: featurelangParser  */
static	ANTLR_BITWORD FOLLOW_INTEGER_in_square163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  featurelangParserImplTraits::BitsetListType FOLLOW_INTEGER_in_square163( FOLLOW_INTEGER_in_square163_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start formula
 * artilib\\grammars\\featurelang.g:8:1: formula : orExpr ;
 */
void
featurelangParser::formula()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:9:2: ( orExpr )
        // artilib\\grammars\\featurelang.g:9:4: orExpr
        {
            this->followPush(FOLLOW_orExpr_in_formula29);
            orExpr();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleformulaEx; /* Prevent compiler warnings */
    ruleformulaEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end formula */

/**
 * $ANTLR start term
 * artilib\\grammars\\featurelang.g:12:1: term : ( ground | '(' orExpr ')' | '!' term );
 */
void
featurelangParser::term()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  artilib\\grammars\\featurelang.g:13:2: ( ground | '(' orExpr ')' | '!' term )

            ANTLR_UINT32 alt1;

            alt1=3;

            switch ( this->LA(1) )
            {
            case 14:
            	{
            		alt1=1;
            	}
                break;
            case 10:
            	{
            		alt1=2;
            	}
                break;
            case 8:
            	{
            		alt1=3;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< featurelangParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 1 );
                ex->set_state( 0 );


                goto ruletermEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // artilib\\grammars\\featurelang.g:13:4: ground
        	    {
        	        this->followPush(FOLLOW_ground_in_term43);
        	        ground();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // artilib\\grammars\\featurelang.g:14:4: '(' orExpr ')'
        	    {
        	         this->matchToken(10, &FOLLOW_10_in_term48);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	        this->followPush(FOLLOW_orExpr_in_term50);
        	        orExpr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	         this->matchToken(11, &FOLLOW_11_in_term52);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // artilib\\grammars\\featurelang.g:15:4: '!' term
        	    {
        	         this->matchToken(8, &FOLLOW_8_in_term57);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	        this->followPush(FOLLOW_term_in_term59);
        	        term();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start orExpr
 * artilib\\grammars\\featurelang.g:17:1: orExpr : andExpr ( '|' andExpr )* ;
 */
void
featurelangParser::orExpr()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:18:2: ( andExpr ( '|' andExpr )* )
        // artilib\\grammars\\featurelang.g:18:4: andExpr ( '|' andExpr )*
        {
            this->followPush(FOLLOW_andExpr_in_orExpr68);
            andExpr();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorExprEx;
            }


            // artilib\\grammars\\featurelang.g:18:12: ( '|' andExpr )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 15:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // artilib\\grammars\\featurelang.g:18:13: '|' andExpr
            	    {
            	         this->matchToken(15, &FOLLOW_15_in_orExpr71);
            	        if  (this->hasException())
            	        {
            	            goto ruleorExprEx;
            	        }


            	        this->followPush(FOLLOW_andExpr_in_orExpr73);
            	        andExpr();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorExprEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorExprEx; /* Prevent compiler warnings */
    ruleorExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end orExpr */

/**
 * $ANTLR start andExpr
 * artilib\\grammars\\featurelang.g:20:1: andExpr : term ( '&' term )* ;
 */
void
featurelangParser::andExpr()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:21:2: ( term ( '&' term )* )
        // artilib\\grammars\\featurelang.g:21:4: term ( '&' term )*
        {
            this->followPush(FOLLOW_term_in_andExpr84);
            term();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleandExprEx;
            }


            // artilib\\grammars\\featurelang.g:21:9: ( '&' term )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case 9:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // artilib\\grammars\\featurelang.g:21:10: '&' term
            	    {
            	         this->matchToken(9, &FOLLOW_9_in_andExpr87);
            	        if  (this->hasException())
            	        {
            	            goto ruleandExprEx;
            	        }


            	        this->followPush(FOLLOW_term_in_andExpr89);
            	        term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleandExprEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleandExprEx; /* Prevent compiler warnings */
    ruleandExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end andExpr */

/**
 * $ANTLR start ground
 * artilib\\grammars\\featurelang.g:24:1: ground : state_set '@' square_set ;
 */
void
featurelangParser::ground()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:25:2: ( state_set '@' square_set )
        // artilib\\grammars\\featurelang.g:25:4: state_set '@' square_set
        {
            this->followPush(FOLLOW_state_set_in_ground103);
            state_set();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegroundEx;
            }


             this->matchToken(13, &FOLLOW_13_in_ground105);
            if  (this->hasException())
            {
                goto rulegroundEx;
            }


            this->followPush(FOLLOW_square_set_in_ground107);
            square_set();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegroundEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegroundEx; /* Prevent compiler warnings */
    rulegroundEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ground */

/**
 * $ANTLR start state_set
 * artilib\\grammars\\featurelang.g:28:1: state_set : '{' ID ( ID )* '}' ;
 */
void
featurelangParser::state_set()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:29:2: ( '{' ID ( ID )* '}' )
        // artilib\\grammars\\featurelang.g:29:4: '{' ID ( ID )* '}'
        {
             this->matchToken(14, &FOLLOW_14_in_state_set118);
            if  (this->hasException())
            {
                goto rulestate_setEx;
            }


             this->matchToken(ID, &FOLLOW_ID_in_state_set120);
            if  (this->hasException())
            {
                goto rulestate_setEx;
            }


            // artilib\\grammars\\featurelang.g:29:11: ( ID )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case ID:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // artilib\\grammars\\featurelang.g:29:12: ID
            	    {
            	         this->matchToken(ID, &FOLLOW_ID_in_state_set123);
            	        if  (this->hasException())
            	        {
            	            goto rulestate_setEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


             this->matchToken(16, &FOLLOW_16_in_state_set127);
            if  (this->hasException())
            {
                goto rulestate_setEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestate_setEx; /* Prevent compiler warnings */
    rulestate_setEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end state_set */

/**
 * $ANTLR start square_set
 * artilib\\grammars\\featurelang.g:32:1: square_set : '{' square ( square )* '}' ;
 */
void
featurelangParser::square_set()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:33:2: ( '{' square ( square )* '}' )
        // artilib\\grammars\\featurelang.g:33:4: '{' square ( square )* '}'
        {
             this->matchToken(14, &FOLLOW_14_in_square_set138);
            if  (this->hasException())
            {
                goto rulesquare_setEx;
            }


            this->followPush(FOLLOW_square_in_square_set140);
            square();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesquare_setEx;
            }


            // artilib\\grammars\\featurelang.g:33:15: ( square )*

            for (;;)
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case INTEGER:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // artilib\\grammars\\featurelang.g:33:16: square
            	    {
            	        this->followPush(FOLLOW_square_in_square_set143);
            	        square();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesquare_setEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


             this->matchToken(16, &FOLLOW_16_in_square_set147);
            if  (this->hasException())
            {
                goto rulesquare_setEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesquare_setEx; /* Prevent compiler warnings */
    rulesquare_setEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end square_set */

/**
 * $ANTLR start square
 * artilib\\grammars\\featurelang.g:36:1: square : INTEGER '.' INTEGER ;
 */
void
featurelangParser::square()
{
        featurelangParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // artilib\\grammars\\featurelang.g:37:2: ( INTEGER '.' INTEGER )
        // artilib\\grammars\\featurelang.g:37:5: INTEGER '.' INTEGER
        {
             this->matchToken(INTEGER, &FOLLOW_INTEGER_in_square159);
            if  (this->hasException())
            {
                goto rulesquareEx;
            }


             this->matchToken(12, &FOLLOW_12_in_square161);
            if  (this->hasException())
            {
                goto rulesquareEx;
            }


             this->matchToken(INTEGER, &FOLLOW_INTEGER_in_square163);
            if  (this->hasException())
            {
                goto rulesquareEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesquareEx; /* Prevent compiler warnings */
    rulesquareEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end square */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */
